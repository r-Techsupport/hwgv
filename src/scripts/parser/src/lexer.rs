// Nom docs:
// https://github.com/rust-bakery/nom/tree/main/doc

pub mod lexer {
    use nom::branch::alt;
    use nom::bytes::complete::{is_not, take_till};
    use nom::character::complete::char as nom_char;
    use nom::combinator::eof;
    use nom::{
        bytes::complete::{tag, take_until},
        multi::many0,
        sequence::{delimited, terminated},
        IResult,
    };
    use std::error::Error;

    /// Given a buffer of ISO-8859-1 encoded characters, lex it and return
    /// a vec of lexed records.
    pub fn lex_csv(csv: &str) -> Result<Vec<Vec<&str>>, Box<dyn Error + '_>> {
        // each record is parsed into a vec of `&str`s, and is added here
        // as the input is iterated over
        let mut output: Vec<Vec<&str>> = Vec::with_capacity(1024);

        let mut record_parse_result: (&str, Vec<&str>) = read_record(csv)?;
        // add the output from the "first round" into the output
        output.push(record_parse_result.1);
        // iterate over the record as long as there's still stuff left to parse
        while record_parse_result.0 != "" {
            record_parse_result = read_record(record_parse_result.0)?;
            output.push(record_parse_result.1);
        }
        Ok(output)
    }

    /// Given that the provided input string is from a HWInfo CSV, read one record from it,
    /// consuming up to the first newline, and returning a [nom::IResult] containing the parsed record.
    ///
    /// **Note: this assumes that the provided input has trailing commas**
    /// # Arguments
    ///
    /// * `input` - A string slice from a csv generated by HWInfo.
    fn read_record(input: &str) -> IResult<&str, Vec<&str>> {
        let record: (&str, &str) = terminated(alt((take_until("\n"), is_not(""))), alt((tag("\n"), take_until(""))))(input)?;
        // apply the parser a bunch of times, until the input string is empty
        let record_parsing_output = many0(read_field)(record.1)?;
        // I want this function to integrate smoothly and behave like an idiomatic nom function
        // so take the leftovers from the record parsing and return *that* as the input
        // the record parsing output should *never* have leftovers unless the input is not valid
        Ok((record.0, record_parsing_output.1))
    }

    /// Given that the provided input string is from a HWInfo CSV, read one field from it,
    /// consuming up to the end of the first record, and returning a [nom::IResult] containing the parsed field
    /// # Arguments
    ///
    /// * `input` - A string slice from a csv generated by HWInfo.
    fn read_field(input: &str) -> IResult<&str, &str> {
        // if the input starts with a quote, read until a quote and a comma
        // otherwise, just read until a comma
        if input.starts_with('"') {
            delimited(nom_char('"'), take_until("\","), tag("\","))(input)
        } else {
            terminated(take_until(","), tag(","))(input)
        }
    }

    #[cfg(test)]
    mod tests {
        use super::*;

        // read_field
        #[test]
        fn basic_read_field_with_quotes() {
            // should consume the entire field, including the comma,
            // and return nothing but a parsed field
            assert_eq!(read_field("\"ab\","), Ok(("", "ab")));
        }

        #[test]
        fn read_field_ignore_quoted_comma() {
            assert_eq!(read_field("\"a,a\","), Ok(("", "a,a")));
        }

        #[test]
        fn basic_read_field_without_quotes() {
            // should consume the entire field, and the comma after,
            // returning the field and nothing else
            assert_eq!(read_field("ab,"), Ok(("", "ab")));
        }

        #[test]
        fn read_field_returns_leftovers() {
            assert_eq!(read_field("ab,cd,"), Ok(("cd,", "ab")));
        }

        #[test]
        fn basic_read_record_until_newline() {
            assert_eq!(read_record("ab,cd,\n"), Ok(("", vec!["ab", "cd"])));
        }

        #[test]
        fn read_record_until_eof() {
            assert_eq!(read_record("ab,cd,"), Ok(("", vec!["ab", "cd"])));
        }

        #[test]
        fn read_record_includes_leftovers() {
            assert_eq!(
                read_record("ab,cd,\nleftovers\n"),
                Ok(("leftovers\n", vec!["ab", "cd"]))
            );
        }

        #[test]
        fn basic_lex_csv() {
            let mock_csv = "a,b,c,\nd,e,f,\ng,h,i,\n";
            let expected_output = vec![
                vec!["a", "b", "c"],
                vec!["d", "e", "f"],
                vec!["g", "h", "i"],
            ];
            // something something box dyn error doesn't implement eq
            assert_eq!(lex_csv(mock_csv).unwrap(), expected_output);
        }
    }
}
